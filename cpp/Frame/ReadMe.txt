AssetSys：资源文件系统，项目中主要依赖于该文件系统，可解耦于文件具体的位置所在，索引方式等。即相同的文件使用方式，
具体到具体文件，则该文件可以是系统文件系统的目录A下，也可以在目录B下，还可以是内存中的某处。
发布版本的时候，文件系统的打包与加解密，对应用层来说都是透明的。
其中apps/AssetExplore是该资源文件系统的可视化编辑工具。

Public、PubMix、PublicX都是框架各方面功能的集合，区分之原因可参见cpp目录下的ReadMe.txt，此处只介绍框架所支持的需要注意的机制。

BufCall：是个自动序列化的机制，类似boost.serialization。主要应用于网络通信的自动序列化与解析。
其实现多借鉴于luabind，以tcp网络通信为例，每次发包相当于通过网络异步或同步调用对方一个函数，那么对于发包方来说，
只需要告诉要调用的函数名以及参数信息，对于收包方来说，只需要提供相应函数名的函数。其中发包方的参数序列化都是自动的，
收包方的函数参数的解析也是自动的，当远程收到该包，则自动解析出函数参数，并调用之。
从这个意义来讲，比较像RPC，所以才将之命名为BufCall。

FuncObj：tcp-ip通信机制，底层用的是boost.asio库，设计与实现并不复杂，设计之初更多地想要模仿com通信技术，
后来觉得并无必要，然后把它实现简化了，直至现在的版本。加上BufCall机制的协作，对于应用层来说，基本上可以无视FuncObj了。

Hooker：抽象并封装了hook的底层实现细节，让hook函数避免去维护堆栈细节，做到在hook函数内像普通函数一样自由地写代码。

异常：所有框架异常都继承自CmnExceptionBase，可自动处理lua、luabind、c++之间的异常传递，对应用层来说是透明的，
CmnExceptionBase异常与DummySleep函数的协调运作，奠定了此框架下游戏辅助开发的方式与基调，在自身定位方面意义非常。
同时也让单线程下具有异步的效果，但又无多线程和协程的复杂性和不稳定性。它们是项目中很多其他机制的基石，比如Action、脚本事件、Timer等。

Database：数据库支持，使得数据库方面的操作具有sql语句方式的简洁效果。

LogOut：日志系统，对boost.log进行封装，使之更方便、简洁，对本项目进行适配。支持输出日志到文件和DbgView。

IoTimer：计时器，支持以毫秒为单位的计时器。

Iterator：迭代器模式的模板实现，支持到lua的for迭代。

lua：通过diy lua和luabind，支持中文脚本，c++调试模式下的lua堆栈变量的输出等。

Cmn_AppBase类族：类似CWinApp，抽象可执行模块，一个Cmn_AppBase既可以是基于MFC的CWinApp，又可以是基于wxWidgets的app，还可以是dll。
其中Cmn_AppBaseFactory类族是典型的工厂模式，以便达到为app配置各种组件的目的，组件包括通信、脚本方面、辅助游戏逻辑等实现细节，
一般而言，使用框架默认的组件即可。

RStd：全称为Release of Std，即标准库的release版。标准库中debug版和release版中的数据结构很多都是不一样的，
主要应用于数据分析，因为游戏中的数据结构很多都是应用的标准库中的，但都是release版的，RStd可以让人避免去实现这样的算法细节。

WgFacility：提供了辅助游戏逻辑方面比较常用的功能，包括优化过后的A星算法，过滤器(filter，比如物品过滤、技能过滤、游戏对象过滤等)，
地图坐标录制相关(CmnMapPath)，任务处理(CmnQuestHandler)，场景处理(CmnSceneHandler)，最短路径(ShortestPaths)等。

GGameObjBase、GGameObjMgrBase：辅助对象到游戏对象的对应对象，比如游戏里的角色对象，那么辅助里就有一个Player类表示角色，
辅助里的Player对象称之为代理对象。代理对象数据的更新为主动触发型，即根据需要去更新对象数据。
游戏逻辑中到处可见各种对象，所以GGameObjBase、GGameObjMgrBase虽然看起来仅仅只定义了这么个抽象，但这个抽象挺重要。

Action：CA_IAction类族，与异常等的协作，让游戏逻辑中角色同时做多件事情成为了比较容易的工作。


以上是框架方面部分功能或机制的简要介绍，细览代码，发现好多东西未能在此尽述，想写上来吧，
发现只可意会，难以言传，不写吧，难不成这几年为之努力的框架就那么点东西吗？真若如此，自己都觉得对不起自己。
思量再三，还是不写了吧，究其原因，概因自己目前水平所限，仅此而已。
